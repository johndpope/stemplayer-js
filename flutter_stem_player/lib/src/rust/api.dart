// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `get_db`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `fmt`

/// Initialize the audio palette database
void initDatabase({required String dbPath}) =>
    AudioPalette.instance.api.crateApiInitDatabase(dbPath: dbPath);

/// Add a sound file to the database
Future<PlatformInt64> addSound({required String filepath}) =>
    AudioPalette.instance.api.crateApiAddSound(filepath: filepath);

/// Get all sounds in the database
Future<List<SoundRecord>> getAllSounds() =>
    AudioPalette.instance.api.crateApiGetAllSounds();

/// Get sound count
PlatformInt64 getSoundCount() =>
    AudioPalette.instance.api.crateApiGetSoundCount();

/// Search sounds by filename
Future<List<SoundRecord>> searchSounds({required String query}) =>
    AudioPalette.instance.api.crateApiSearchSounds(query: query);

/// Find similar sounds to a query file
Future<List<MatchResult>> findSimilar(
        {required String queryPath,
        required double threshold,
        required BigInt maxResults}) =>
    AudioPalette.instance.api.crateApiFindSimilar(
        queryPath: queryPath, threshold: threshold, maxResults: maxResults);

/// Find similar sounds with segment matching (returns exact time ranges)
Future<List<MatchResult>> findSimilarWithSegments(
        {required String queryPath,
        required double threshold,
        required BigInt maxResults}) =>
    AudioPalette.instance.api.crateApiFindSimilarWithSegments(
        queryPath: queryPath, threshold: threshold, maxResults: maxResults);

/// Find similar sounds from audio samples (for selection-based search)
Future<List<MatchResult>> findSimilarFromSamples(
        {required List<double> samples,
        required int sampleRate,
        required double threshold,
        required BigInt maxResults}) =>
    AudioPalette.instance.api.crateApiFindSimilarFromSamples(
        samples: samples,
        sampleRate: sampleRate,
        threshold: threshold,
        maxResults: maxResults);

/// Export match results to MIDI file
Future<void> exportToMidi(
        {required List<MatchResult> matches,
        required String outputPath,
        required int tempoBpm,
        required int baseNote}) =>
    AudioPalette.instance.api.crateApiExportToMidi(
        matches: matches,
        outputPath: outputPath,
        tempoBpm: tempoBpm,
        baseNote: baseNote);

/// Export match results to CSV file
Future<void> exportToCsv(
        {required List<MatchResult> matches, required String outputPath}) =>
    AudioPalette.instance.api
        .crateApiExportToCsv(matches: matches, outputPath: outputPath);

/// Export match results to markers file
Future<void> exportToMarkers(
        {required List<MatchResult> matches, required String outputPath}) =>
    AudioPalette.instance.api
        .crateApiExportToMarkers(matches: matches, outputPath: outputPath);

/// Remove a sound from the database
Future<void> removeSound({required PlatformInt64 soundId}) =>
    AudioPalette.instance.api.crateApiRemoveSound(soundId: soundId);

/// Extract audio fingerprint from file (for debugging/display)
Future<AudioFingerprintInfo> getFingerprint({required String filepath}) =>
    AudioPalette.instance.api.crateApiGetFingerprint(filepath: filepath);

/// Compute similarity between two fingerprints (0-100)
double computeSimilarity({required String fp1Path, required String fp2Path}) =>
    AudioPalette.instance.api
        .crateApiComputeSimilarity(fp1Path: fp1Path, fp2Path: fp2Path);

/// Simplified fingerprint info for Flutter
class AudioFingerprintInfo {
  final double duration;
  final double spectralCentroid;
  final double spectralBandwidth;
  final double spectralRolloff;
  final Float64List mfccMean;
  final Float64List mfccStd;

  const AudioFingerprintInfo({
    required this.duration,
    required this.spectralCentroid,
    required this.spectralBandwidth,
    required this.spectralRolloff,
    required this.mfccMean,
    required this.mfccStd,
  });

  @override
  int get hashCode =>
      duration.hashCode ^
      spectralCentroid.hashCode ^
      spectralBandwidth.hashCode ^
      spectralRolloff.hashCode ^
      mfccMean.hashCode ^
      mfccStd.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AudioFingerprintInfo &&
          runtimeType == other.runtimeType &&
          duration == other.duration &&
          spectralCentroid == other.spectralCentroid &&
          spectralBandwidth == other.spectralBandwidth &&
          spectralRolloff == other.spectralRolloff &&
          mfccMean == other.mfccMean &&
          mfccStd == other.mfccStd;
}
